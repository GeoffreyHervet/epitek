B1;2601;0c#ifndef		_OPERANDS_HH_
#define		_OPERANDS_HH_

#include	<string>
#include	<iostream>
#include	<sstream>

#include	"IOperand.hh"
#include	"except.hh"

namespace	avm
{

  template <typename T>
  class Operand : public IOperand
  {
<<<<<<< .mine
    public:
      Operand(std::string val, eOperandType type)
        : type(type), str(val)
      {

        std::stringstream     a;
=======
  public:
    Operand(std::string val, eOperandType type)
    : type(type), str(val)
    {
      std::stringstream     a;
>>>>>>> .r35

<<<<<<< .mine
        a.str(val);
        a >> this->value;

        std::cout << "str = " << val << std::endl;
        std::cout << "value = " << this->value << std::endl;
      };
=======
      a.str(val);
      a >> this->value;
    };
>>>>>>> .r35

    ~Operand(){};

    Operand		*clone() const { return (new Operand<T>(this->toString(), this->type)); };
    std::string const&	toString() const {   return (this->str); };
    int			getPrecision() const {    return (static_cast<int>(this->type));};
    eOperandType	getType() const {    return (this->type); };
    T			getValue() const { return (this->value);};

    IOperand *operator+(const IOperand &rhs) const
    {
      Operand       *result;
      double        tmp;
      std::stringstream     s;

<<<<<<< .mine
      IOperand		*cloneBigestPrec(const IOperand &rhs, std::string val) const
      {
        std::cout << "val = " << val << std::endl;
        std::cout << "-------" << std::endl;
        if (rhs.getPrecision() > this->getPrecision())
          return static_cast<const Operand & > (rhs).clone(val);
        return this->clone(val);
      };
=======
      s.str(rhs.toString());
      s >> tmp;
      result = (rhs.getPrecision() > this->getPrecision() ?
          static_cast<const Operand & > (rhs).clone() : this->clone());
      result->value = this->value + tmp;
      s.clear();
      s << result->value;
      result->str = s.str();
      return (result);
    };
>>>>>>> .r35

<<<<<<< .mine
      IOperand *operator+(const IOperand &rhs) const
      {
        std::cout << __FUNCTION__ << " " << (static_cast<const Operand<int> & >(rhs).getValue()) << ", " << this->value << std::endl;
        return  this->cloneBigestPrec(rhs,utils::toStr(static_cast<const Operand & >(rhs).getValue() + this->value));
      };
=======
    IOperand *operator-(const IOperand &rhs) const
    {
      Operand		*result;
      double		tmp;
      std::stringstream	s;
>>>>>>> .r35

<<<<<<< .mine
      IOperand *operator-(const IOperand &rhs) const
      {
        std::cout << __FUNCTION__ << " " << (static_cast<const Operand & >(rhs).value) << ", " << this->value << std::endl;
        return  this->cloneBigestPrec(rhs,utils::toStr(static_cast<const Operand & >(rhs).getValue() - this->value));
      };
=======
      s.str(rhs.toString());
      s >> tmp;
      result = (rhs.getPrecision() > this->getPrecision() ?
          static_cast<const Operand & > (rhs).clone() : this->clone());
      result->value = this->value - tmp;
      s.clear();
      s << result->value;
      result->str = s.str();
      return (result);
    };
>>>>>>> .r35

<<<<<<< .mine
      IOperand *operator*(const IOperand &rhs) const
      {
        std::cout << __FUNCTION__ << " " << (static_cast<const Operand & >(rhs).value) << ", " << this->value << std::endl;
        return  this->cloneBigestPrec(rhs,utils::toStr(static_cast<const Operand & >(rhs).getValue() * this->value));
      };
=======
    IOperand *operator*(const IOperand &rhs) const
    {
      Operand               *result;
      double                tmp;
      std::stringstream     s;
>>>>>>> .r35

<<<<<<< .mine
      IOperand *operator/(const IOperand &rhs) const
      {
        std::cout << __FUNCTION__ << " " << (static_cast<const Operand & >(rhs).value) << ", " << this->value << std::endl;
        return  this->cloneBigestPrec(rhs,utils::toStr(static_cast<const Operand & >(rhs).getValue() / this->value));
      };
=======
      s.str(rhs.toString());
      s >> tmp;
      result = (rhs.getPrecision() > this->getPrecision() ?
          static_cast<const Operand & > (rhs).clone() : this->clone());
      result->value = this->value * tmp;
      s.clear();
      s << result->value;
      result->str = s.str();
      return (result);
    };
>>>>>>> .r35

<<<<<<< .mine
      IOperand *operator%(const IOperand &rhs) const
      {
        std::cout << __FUNCTION__ << " " << (static_cast<const Operand & >(rhs).value) << ", " << this->value << std::endl;
        return  this->cloneBigestPrec(rhs,utils::toStr(MOD(static_cast<const Operand & >(rhs).getValue(),this->value)));
      };
=======
    IOperand *operator/(const IOperand &rhs) const
    {
      Operand               *result;
      double                tmp;
      std::stringstream     s;
>>>>>>> .r35

      s.str(rhs.toString());
      s >> tmp;
      if (tmp == 0.0)
	throw except("Div by 0");
      result = (rhs.getPrecision() > this->getPrecision() ?
          static_cast<const Operand & > (rhs).clone() : this->clone());
      result->value = this->value / tmp;
      s.clear();
      s << result->value;
      result->str = s.str();
      return (result);
    };

    IOperand *operator%(const IOperand &rhs) const
    {
    Operand       *result;
    int           tmp;
    std::stringstream     s;

    s.str(rhs.toString());
    s >> tmp;
    if (tmp == 0)
      throw except("Error: Modulo by 0");
    if (rhs.getType() == FLOAT || rhs.getType() == DOUBLE)
      throw except("Modulo by decimal");
    result = (rhs.getPrecision() > this->getPrecision() ?
	   static_cast<const Operand &>(rhs).clone() : this->clone());
    result->value = this->value - (this->value / tmp) * tmp;
    s.clear();
    s << result->value;
    result->str = s.str();
    return (result);
    };

  private:
    eOperandType          type;
    std::string           str;
    T                     value;
  };



};

#endif		/* _OPERANDS_HH_ */
